{"mappings":"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","sources":["<anon>","assets/js/script.js"],"sourcesContent":["// Function to adjust dates to local time by adding the offset\nfunction adjustToLocalTime(dateString) {\n    const date = new Date(dateString);\n    date.setMinutes(date.getMinutes() + date.getTimezoneOffset()); // Adjusts to local time\n    return date;\n}\n// Function to calculate the age if the person is still alive\nfunction getAge(birthDate) {\n    const birth = adjustToLocalTime(birthDate);\n    const today = new Date();\n    let age = today.getFullYear() - birth.getFullYear();\n    if (today.getMonth() < birth.getMonth() || today.getMonth() === birth.getMonth() && today.getDate() < birth.getDate()) age--;\n    return age.toString();\n}\n// Function to get the lifespan in the format \"birthYear - deathYear\"\nfunction getLifeSpan(birthDate, deathDate) {\n    const birth = adjustToLocalTime(birthDate);\n    const death = adjustToLocalTime(deathDate);\n    const birthYear = birth.getFullYear();\n    const deathYear = death.getFullYear();\n    return `${birthYear} - ${deathYear}`;\n}\nfunction buildParentConnections(data, nodes) {\n    data.forEach((person)=>{\n        const node = nodes[person.id - 1];\n        const motherFirstName = person.motherFirstName.split(\" \")[0];\n        const fatherFirstName = person.fatherFirstName.split(\" \")[0];\n        if (motherFirstName && fatherFirstName) {\n            // Find all potential mothers and fathers with matching first names\n            const potentialMothers = data.filter((p)=>p.firstName === motherFirstName);\n            const potentialFathers = data.filter((p)=>p.firstName === fatherFirstName);\n            // Identify mother-father pairs that are spouses\n            let mother = null;\n            let father = null;\n            for (let m of potentialMothers){\n                for (let f of potentialFathers)// Check if the mother-father pair are spouses\n                if (nodes[m.id - 1].pids.includes(f.id)) {\n                    mother = m;\n                    father = f;\n                    break;\n                }\n                if (mother && father) break;\n            }\n            // Assign the mother and father IDs if a matching spouse pair is found\n            if (mother) node.mid = mother.id;\n            if (father) node.fid = father.id;\n        }\n    });\n    // Sort children by birth date for each parent-child group\n    data.forEach((person)=>{\n        const motherFirstName = person.motherFirstName.split(\" \")[0];\n        const fatherFirstName = person.fatherFirstName.split(\" \")[0];\n        if (motherFirstName && fatherFirstName) {\n            let children = data.filter((child)=>child.motherFirstName && child.motherFirstName.split(\" \")[0] === motherFirstName && child.fatherFirstName && child.fatherFirstName.split(\" \")[0] === fatherFirstName);\n            children.sort((a, b)=>new Date(a.birthDate) - new Date(b.birthDate));\n            // Update children in nodes by order of birth date\n            children.forEach((child, index)=>{\n                nodes[child.id - 1].siblingOrder = index;\n            });\n        }\n    });\n    // Reorder the nodes array based on sibling order for visualization\n    nodes.sort((a, b)=>(a.siblingOrder || 0) - (b.siblingOrder || 0));\n}\nfunction buildSpouseConnections(data, nodes) {\n    // Build spouse connections\n    data.forEach((person)=>{\n        if (person.spouseFirstName && person.spouseLastName) {\n            const spouse = data.find((p)=>p.firstName === person.spouseFirstName && p.lastName === person.spouseLastName);\n            if (spouse) {\n                nodes[person.id - 1].pids.push(spouse.id); // Connect spouses\n                nodes[spouse.id - 1].pids.push(person.id); // Ensure both sides are connected\n            }\n        }\n    });\n}\nfunction buildNodes(data) {\n    const nodes = data.map((person)=>({\n            id: person.id,\n            name: `${person.firstName} ${person.lastName}`,\n            img: person.directPhotoUrl.replace(\"https://drive.google.com/uc?export=view&id=\", \"https://drive.google.com/thumbnail?id=\"),\n            pids: [],\n            mid: null,\n            fid: null,\n            age: person.deathDate == \"\" ? \"\\u05D2\\u05D9\\u05DC: \" + getAge(person.birthDate) : getLifeSpan(person.birthDate, person.deathDate)\n        }));\n    return nodes;\n}\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    console.log(\"Initializing data fetch\");\n    document.getElementById(\"spinner\").style.display = \"block\";\n    const dataUrl = \"https://script.google.com/macros/s/AKfycbyTqzU-lZ2XFk6xvkwKqQq8eGHOX85k1hDxy1-Qj1Pw9KDQcvfKTQELQImNpenELfa9ew/exec\";\n    fetch(dataUrl).then((response)=>{\n        console.log(`Received response with status: ${response.status}`);\n        if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);\n        return response.json();\n    }).then((data)=>{\n        console.log(\"Fetched data:\", data);\n        buildFamilyTree(data);\n    }).catch((error)=>{\n        console.error(\"Fetch error:\", error);\n        document.getElementById(\"spinner\").style.display = \"none\";\n    });\n});\nfunction buildFamilyTree(data) {\n    document.getElementById(\"spinner\").style.display = \"none\";\n    // Assign a unique id for each person\n    data.forEach((person, index)=>{\n        person.id = index + 1;\n    });\n    // Map the data to nodes for FamilyTree.js\n    const nodes = buildNodes(data);\n    buildSpouseConnections(data, nodes);\n    buildParentConnections(data, nodes);\n    // temp hard coded fix - need to fix later!\n    nodes[0][\"pids\"].pop();\n    nodes[1][\"pids\"].pop();\n    // Initialize FamilyTree.js with custom sibling spacing\n    new FamilyTree(document.getElementById(\"tree\"), {\n        template: \"john\",\n        dataSource: nodes,\n        nodeBinding: {\n            field_0: \"name\",\n            field_1: \"age\",\n            img_0: \"img\"\n        },\n        // mouseScrool: FamilyTree.action.none,\n        nodes: nodes,\n        enableSearch: false,\n        nodeMouseClick: false,\n        partnerNodeSeparation: -119,\n        levelSeparation: 80,\n        minPartnerSeparation: 20\n    });\n    console.log(\"Final Nodes:\", nodes);\n}\n\n//# sourceMappingURL=index.abc2d42d.js.map\n","// Function to adjust dates to local time by adding the offset\nfunction adjustToLocalTime(dateString) {\n\tconst date = new Date(dateString);\n\tdate.setMinutes(date.getMinutes() + date.getTimezoneOffset()); // Adjusts to local time\n\treturn date;\n}\n\n// Function to calculate the age if the person is still alive\nfunction getAge(birthDate) {\n\tconst birth = adjustToLocalTime(birthDate);\n\tconst today = new Date();\n\n\tlet age = today.getFullYear() - birth.getFullYear();\n\tif (\n\t\ttoday.getMonth() < birth.getMonth() ||\n\t\t(today.getMonth() === birth.getMonth() && today.getDate() < birth.getDate())\n\t) {\n\t\tage--;\n\t}\n\treturn age.toString();\n}\n\n// Function to get the lifespan in the format \"birthYear - deathYear\"\nfunction getLifeSpan(birthDate, deathDate) {\n\tconst birth = adjustToLocalTime(birthDate);\n\tconst death = adjustToLocalTime(deathDate);\n\n\tconst birthYear = birth.getFullYear();\n\tconst deathYear = death.getFullYear();\n\treturn `${birthYear} - ${deathYear}`;\n}\n\nfunction buildParentConnections(data, nodes) {\n\tdata.forEach((person) => {\n\t\tconst node = nodes[person.id - 1];\n\t\tconst motherFirstName = person.motherFirstName.split(\" \")[0];\n\t\tconst fatherFirstName = person.fatherFirstName.split(\" \")[0];\n\n\t\tif (motherFirstName && fatherFirstName) {\n\t\t\t// Find all potential mothers and fathers with matching first names\n\t\t\tconst potentialMothers = data.filter((p) => p.firstName === motherFirstName);\n\t\t\tconst potentialFathers = data.filter((p) => p.firstName === fatherFirstName);\n\n\t\t\t// Identify mother-father pairs that are spouses\n\t\t\tlet mother = null;\n\t\t\tlet father = null;\n\t\t\tfor (let m of potentialMothers) {\n\t\t\t\tfor (let f of potentialFathers) {\n\t\t\t\t\t// Check if the mother-father pair are spouses\n\t\t\t\t\tif (nodes[m.id - 1].pids.includes(f.id)) {\n\t\t\t\t\t\tmother = m;\n\t\t\t\t\t\tfather = f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mother && father) break;\n\t\t\t}\n\n\t\t\t// Assign the mother and father IDs if a matching spouse pair is found\n\t\t\tif (mother) node.mid = mother.id;\n\t\t\tif (father) node.fid = father.id;\n\t\t}\n\t});\n\n\t// Sort children by birth date for each parent-child group\n\tdata.forEach((person) => {\n\t\tconst motherFirstName = person.motherFirstName.split(\" \")[0];\n\t\tconst fatherFirstName = person.fatherFirstName.split(\" \")[0];\n\t\tif (motherFirstName && fatherFirstName) {\n\t\t\tlet children = data.filter(\n\t\t\t\t(child) =>\n\t\t\t\t\tchild.motherFirstName &&\n\t\t\t\t\tchild.motherFirstName.split(\" \")[0] === motherFirstName &&\n\t\t\t\t\tchild.fatherFirstName &&\n\t\t\t\t\tchild.fatherFirstName.split(\" \")[0] === fatherFirstName\n\t\t\t);\n\t\t\tchildren.sort((a, b) => new Date(a.birthDate) - new Date(b.birthDate));\n\n\t\t\t// Update children in nodes by order of birth date\n\t\t\tchildren.forEach((child, index) => {\n\t\t\t\tnodes[child.id - 1].siblingOrder = index;\n\t\t\t});\n\t\t}\n\t});\n\n\t// Reorder the nodes array based on sibling order for visualization\n\tnodes.sort((a, b) => (a.siblingOrder || 0) - (b.siblingOrder || 0));\n}\n\nfunction buildSpouseConnections(data, nodes) {\n\t// Build spouse connections\n\tdata.forEach((person) => {\n\t\tif (person.spouseFirstName && person.spouseLastName) {\n\t\t\tconst spouse = data.find((p) => p.firstName === person.spouseFirstName && p.lastName === person.spouseLastName);\n\t\t\tif (spouse) {\n\t\t\t\tnodes[person.id - 1].pids.push(spouse.id); // Connect spouses\n\t\t\t\tnodes[spouse.id - 1].pids.push(person.id); // Ensure both sides are connected\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction buildNodes(data) {\n\tconst nodes = data.map((person) => ({\n\t\tid: person.id,\n\t\tname: `${person.firstName} ${person.lastName}`,\n\t\timg: person.directPhotoUrl.replace(\n\t\t\t\"https://drive.google.com/uc?export=view&id=\",\n\t\t\t\"https://drive.google.com/thumbnail?id=\"\n\t\t),\n\t\tpids: [], // Spouse connections\n\t\tmid: null, // Mother's ID\n\t\tfid: null, // Father's ID\n\t\tage: person.deathDate == \"\" ? \"גיל: \" + getAge(person.birthDate) : getLifeSpan(person.birthDate, person.deathDate),\n\t}));\n\n\treturn nodes;\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n\tconsole.log(\"Initializing data fetch\");\n\tdocument.getElementById(\"spinner\").style.display = \"block\";\n\n\tconst dataUrl =\n\t\t\"https://script.google.com/macros/s/AKfycbyTqzU-lZ2XFk6xvkwKqQq8eGHOX85k1hDxy1-Qj1Pw9KDQcvfKTQELQImNpenELfa9ew/exec\";\n\n\tfetch(dataUrl)\n\t\t.then((response) => {\n\t\t\tconsole.log(`Received response with status: ${response.status}`);\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`Network response was not ok: ${response.statusText}`);\n\t\t\t}\n\t\t\treturn response.json();\n\t\t})\n\t\t.then((data) => {\n\t\t\tconsole.log(\"Fetched data:\", data);\n\t\t\tbuildFamilyTree(data);\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error(\"Fetch error:\", error);\n\t\t\tdocument.getElementById(\"spinner\").style.display = \"none\";\n\t\t});\n});\n\nfunction buildFamilyTree(data) {\n\tdocument.getElementById(\"spinner\").style.display = \"none\";\n\n\t// Assign a unique id for each person\n\tdata.forEach((person, index) => {\n\t\tperson.id = index + 1;\n\t});\n\n\t// Map the data to nodes for FamilyTree.js\n\tconst nodes = buildNodes(data);\n\n\tbuildSpouseConnections(data, nodes);\n\tbuildParentConnections(data, nodes);\n\n\t// temp hard coded fix - need to fix later!\n\tnodes[0][\"pids\"].pop();\n\tnodes[1][\"pids\"].pop();\n\n\t// Initialize FamilyTree.js with custom sibling spacing\n\tnew FamilyTree(document.getElementById(\"tree\"), {\n\t\ttemplate: \"john\",\n\t\tdataSource: nodes,\n\t\tnodeBinding: {\n\t\t\tfield_0: \"name\",\n\t\t\tfield_1: \"age\",\n\t\t\timg_0: \"img\",\n\t\t},\n\t\t// mouseScrool: FamilyTree.action.none,\n\t\tnodes: nodes,\n\t\tenableSearch: false,\n\t\tnodeMouseClick: false,\n\t\tpartnerNodeSeparation: -119,\n\t\tlevelSeparation: 80,\n\t\tminPartnerSeparation: 20,\n        \n\t});\n\n    console.log(\"Final Nodes:\", nodes)\n}\n\n\n"],"names":["adjustToLocalTime","dateString","date","Date","setMinutes","getMinutes","getTimezoneOffset","document","addEventListener","console","log","getElementById","style","display","fetch","then","response","status","ok","Error","statusText","json","data","buildFamilyTree","forEach","person","index","id","nodes","map","name","firstName","lastName","img","directPhotoUrl","replace","pids","mid","fid","age","deathDate","getAge","birthDate","birth","today","getFullYear","getMonth","getDate","toString","getLifeSpan","death","birthYear","deathYear","buildSpouseConnections","spouseFirstName","spouseLastName","spouse","find","p","push","node","motherFirstName","split","fatherFirstName","potentialMothers","filter","potentialFathers","mother","father","m","f","includes","children","child","sort","a","b","siblingOrder","pop","FamilyTree","template","dataSource","nodeBinding","field_0","field_1","img_0","enableSearch","nodeMouseClick","partnerNodeSeparation","levelSeparation","minPartnerSeparation","catch","error"],"version":3,"file":"index.abc2d42d.js.map"}